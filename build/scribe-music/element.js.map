{
  "version": 3,
  "sources": ["https://cdn.jsdelivr.net/gh/stephband/fn@1.5.1/modules/signal.js", "https://cdn.jsdelivr.net/gh/stephband/fn@1.5.1/modules/exec.js", "https://cdn.jsdelivr.net/gh/stephband/fn@1.5.1/modules/capture.js", "https://cdn.jsdelivr.net/gh/stephband/dom@1.4.1/modules/element/internals.js", "https://cdn.jsdelivr.net/gh/stephband/dom@1.4.1/modules/element.js", "https://cdn.jsdelivr.net/gh/stephband/fn@1.5.1/modules/to-type.js", "https://cdn.jsdelivr.net/gh/stephband/fn@1.5.1/modules/stream/stopable.js", "https://cdn.jsdelivr.net/gh/stephband/fn@1.5.1/modules/stream/stream.js", "https://cdn.jsdelivr.net/gh/stephband/dom@1.4.1/modules/events.js", "https://cdn.jsdelivr.net/gh/stephband/fn@1.5.1/modules/cache-by-key.js", "https://cdn.jsdelivr.net/gh/stephband/fn@1.5.1/modules/choose.js", "https://cdn.jsdelivr.net/gh/stephband/dom@1.4.1/modules/parse.js", "https://cdn.jsdelivr.net/gh/stephband/dom@1.4.1/modules/request.js", "../../modules/parse/parse-sequence-text.js", "../../modules/parse.js", "../../modules/request-data.js", "../../modules/timesig.js", "../../scribe-music/element.js"],
  "sourcesContent": ["\nconst DEBUG  = false;//window.DEBUG && window.DEBUG.signal !== false;\nconst assign = Object.assign;\n\nlet evaluatingSignal;\nlet hasInvalidDependency;\nlet id = 0;\n\n\nfunction removeInput(signal, input) {\n    // Remove input from stream\n    let i = 0;\n    while (signal[--i] && signal[i] !== input);\n    while (signal[i--]) signal[i + 1] = signal[i];\n}\n\nfunction removeOutput(signal, output) {\n    // Remove output from signal\n    let o = -1;\n    while (signal[++o] && signal[o] !== output);\n    while (signal[o++]) signal[o - 1] = signal[o];\n}\n\nfunction clearInputs(signal) {\n    let n = 0;\n    while (signal[--n]) {\n        // -------------------------- Experimental -----------------------------\n        // Stop inputs? An input with a stop method – an observer – can only have\n        // become a dependency if it were constructed during a render (they don't\n        // evaluate synchronously so they don't become dependencies otherwise).\n        // Therefore also, it can only have one output, this. Therefore it is\n        // safe to stop it. I am right about this am I not?\n        if (signal[n].stop) signal[n].stop();\n        // ---------------------------------------------------------------------\n        signal[n] = undefined;\n    }\n}\n\nfunction setDependency(signal, dependent) {\n    // Set signal as an input of dependent\n    let n = 0;\n    while (dependent[--n]) if (dependent[n] === signal) break;\n    dependent[n] = signal;\n\n    // Set dependent as an output of signal\n    n = -1;\n    while (signal[++n]) if (signal[n] === dependent) break;\n    signal[n] = dependent;\n\n    if (DEBUG) console.log(\n        '%cSignal%c connect%c ' + signal.constructor.name + '#' + signal.id + ' - ' + dependent.constructor.name + '#' + dependent.id,\n        'color: #718893; font-weight: 300;',\n        'color: #3896BF; font-weight: 300;',\n        'color: #718893; font-weight: 300;'\n    );\n}\n\nfunction invalidateDependents(signal) {\n    if (DEBUG) {\n        console.log(\n            '%cSignal%c invalidate%c ' + signal.constructor.name + '#' + signal.id + (signal.name ? ' \"' + signal.name + '\"' : ''),\n            'color: #718893; font-weight: 300;',\n            'color: #3896BF; font-weight: 300;',\n            'color: #718893; font-weight: 300;'\n        );\n    }\n\n    let n = -1;\n    let dependent;\n    while (dependent = signal[++n]) {\n        signal[n] = undefined;\n        dependent.invalidate(signal);\n    }\n}\n\nexport function hasInput(signal, input) {\n    // Check if input exists in the -ve indexes\n    let n = 0;\n    while (signal[--n]) if (signal[n] === input) return true;\n}\n\n\n/**\nSignal\n\nA signal is an object that represents a value that may change. A signal has\nessentially one property, `.value`. A state signal can have its `.value`\nwritten, a compute signal's `.value` may only be read.\n\nThe `Signal` constructor is not called directly, but calling `Signal.of(value)`\ncreates a state signal, and `Signal.from(fn)` creates a compute signal.\n**/\n\nexport default class Signal {\n    /**\n    Signal.isSignal(object)\n\n    Returns `true` where `object` is an instance of `Signal`.\n\n    This guarantees that `object` has a gettable `value` property. This is not\n    true of an Observer, which is not really a signal at all – it cannot\n    have dependencies – but is only evaluated as one when invalidated.\n    **/\n\n    static isSignal(object) {\n        return object instanceof Signal;\n    }\n\n    /**\n    Signal.of()\n    Signal.of(value)\n\n    Creates a state signal that has essentially one property, `.value`.\n    When `.value` is set the signal becomes invalid, stale, out of date,\n    irrelevant, historic, old, and any signals that depend on it are invalidated.\n    **/\n\n    static of(value) {\n        return new ValueSignal(value);\n    }\n\n    /**\n    Signal.from(fn)\n    Signal.from(promise)\n    Signal.from(stream)\n\n    Creates a compute signal from a function, where `fn` computes a value by\n    reading other signals' values. This signal is then invalidated when any of\n    the read signals are invalidated.\n\n    Creates a state signal from a promise or stream that invalidates\n    dependencies as the promise or streams' values resolve.\n    **/\n\n    static from(fn, context) {\n        // Promise\n        if (fn.then) {\n            const signal = Signal.of();\n            fn.then((value) => signal.value = value);\n            return signal;\n        }\n\n        // Pipeable\n        if (fn.pipe) {\n            return fn.pipe(new PushSignal());\n        }\n\n        // Function\n        return new ComputeSignal(fn, context);\n    }\n\n    static compute(fn, context) {\n        return new ComputeSignal(fn, context);\n    }\n\n    static fromProperty(name, object) {\n        // Function\n        return new PropertySignal(name, object);\n    }\n\n    /**\n    Signal.frame(fn, initial)\n    Returns an observe signal, a form of compute signal that calls `fn` once\n    immediately, and then on every animation frame following the invalidation\n    of any signal read during the execution of `fn`.\n    **/\n\n    static frame(fn) {\n        // Add to signals called on invalidation\n        return new FrameSignal(fn);\n    }\n\n    /**\n    Signal.tick(fn, initial)\n    Returns an observe signal, a form of compute signal that calls `fn` once\n    immediately, and then on every tick following the invalidation of any signal\n    read during the execution of `fn`.\n    **/\n\n    static tick(fn) {\n        // Add to signals called on invalidation\n        return new TickSignal(fn);\n    }\n\n    /**\n    Signal.temporal(name, object)\n    Creates a signal with an `.invalidateUntil(time)` method that maintains\n    invalidity until `time` is reached.\n    **/\n\n    static temporal(name, object) {\n        return new TimedSignal(name, object);\n    }\n\n    /**\n    Signal.evaluate(object, fn[, context])\n\n    A function for building objects that behave as compute or observe signals.\n\n    Evaluates `object` as a signal by applying it to `fn` and returning the\n    result. Signals read during `fn()` have `object` registered as a dependent,\n    so `object.invalidate()` is called when any of those signals are invalidated.\n    It's the same function as that used internally to evaluate signals.\n\n    Typically `object.invalidate()` would cue a `Signal.evaluate(object, fn)` at\n    some point in the future. (It is ill-advised to `Signal.evaluate(object, fn)`\n    synchronously inside `.invalidate()`, although this should only lead to\n    wasted cycles, not bad results... errm, in most cases, at least.)\n    **/\n\n    static evaluate(signal, fn, context = signal) {\n        // Make signal the evaluating signal for the duration of this\n        // synchronous evaluation of fn()\n        const previous = evaluatingSignal;\n        evaluatingSignal = signal;\n\n        // Clear the decks\n        if (!previous) hasInvalidDependency = false;\n\n        /*if (window.DEBUG && window.DEBUG.signal !== false) console.group(\n            '%cSignal%c evaluate%c ' + evaluatingSignal.constructor.name + '#' + evaluatingSignal.id + (evaluatingSignal.name ? ' \"' + evaluatingSignal.name + '\"' : ''),\n            'color: #718893; font-weight: 300;',\n            'color: #3896BF; font-weight: 300;',\n            'color: #718893; font-weight: 300;'\n        );*/\n\n        const value = fn.apply(context);\n\n        /*if (window.DEBUG && window.DEBUG.signal !== false) console.groupEnd();*/\n\n        evaluatingSignal = previous;\n\n        // Call synchronous updates\n        //if (!evaluatingSignal) handlers.forEach(call);\n\n        return value;\n    }\n\n    static get hasInvalidDependency() {\n        return hasInvalidDependency;\n    }\n\n    /*\n    Signal.evaluating\n    The signal that is currently being evaluated, or undefined. This is exposed\n    so that Data() can make a better call about when to create signals (if there\n    is no evaluating signal, it needn't make a signal when a property is\n    accessed). Deliberately undocumented.\n    */\n\n    static get evaluating() {\n        return evaluatingSignal;\n    }\n\n    constructor(name) {\n        if (name) this.name = name;\n\n        if (DEBUG) {\n            this.id = ++id;\n            console.log(\n                '%cSignal%c create%c ' + this.constructor.name + '#' + this.id + (this.name ? ' \"' + this.name + '\"' : ''),\n                'color: #718893; font-weight: 300;',\n                'color: #3896BF; font-weight: 300;',\n                'color: #718893; font-weight: 300;'\n            );\n        }\n    }\n\n    /**\n    .valueOf()\n\n    Enables direct use in some expressions like addition or string concatenation.\n    This may prove to be less useful than we think. For one thing, logging a\n    signal object now evaluates it, affecting the outcome.\n    **/\n\n    valueOf() {\n        return this.value;\n    }\n\n    /*\n    .toString()\n    .toJSON()\n\n    Treat `.value` as the value to output?\n    */\n\n    toString() {\n        return this.value + '' ;\n    }\n\n    toJSON() {\n        return this.value;\n    }\n}\n\n\n/*\nValueSignal(value)\n*/\n\nclass ValueSignal extends Signal {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    /**\n    .value\n\n    Getting `.value` gets value from the cache.\n\n    Setting `.value`, assuming the newly set value differs from the previous\n    value, updates the cache and invalidates dependent signals.\n    **/\n\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal, irrespective of state of #value\n        if (evaluatingSignal) setDependency(this, evaluatingSignal);\n        return this.#value;\n    }\n\n    set value(value) {\n        // Don't update for no change in value\n        if(this.#value === value) return;\n\n        // Set cached value\n        this.#value = value;\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble but #valid is true and #value is set so\n        // that's ok I think?\n        invalidateDependents(this);\n    }\n}\n\n\n/*\nPushSignal(value)\nAn consumer interface that allows you to terminate a Stream in a signal.\n\n```js\nStream.of(1).pipe(new PushSignal())\n```\n*/\n\nclass PushSignal extends Signal {\n    #value;\n\n    constructor(value) {\n        super();\n        this.#value = value;\n    }\n\n    /**\n    .value\n    Getting `.value` gets value from the cache.\n    **/\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal, irrespective of state of #value\n        if (evaluatingSignal) setDependency(this, evaluatingSignal);\n        return this.#value;\n    }\n\n    /**\n    .push(value)\n    Updates the cache with `value` and invalidates dependent signals.\n    **/\n    push(value) {\n        // Don't update for no change in value\n        if(this.#value === value) return;\n\n        // Set cached value\n        this.#value = value;\n\n        // Invalidate dependents.\n        invalidateDependents(this);\n    }\n}\n\n\n/*\nPropertySignal(value)\nWraps a property in a signal. TODO: is this really needed?\n*/\n\nclass PropertySignal extends Signal {\n    // Privates\n    #valid;\n    #value;\n\n    constructor(name, object) {\n        super(name);\n        this.object = object;\n    }\n\n    evaluate() {\n        return this.object[this.name];\n    }\n\n    /**\n    .value\n    Getting `.value` gets a cached value or, if the signal is invalid,\n    evaluates (and caches) value from `fn()`. During evaluation this signal is\n    registered as dependent on other signals whose value is got.\n    **/\n\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal, irrespective of state of #value\n        if (evaluatingSignal) setDependency(this, evaluatingSignal);\n        if (this.#valid) return this.#value;\n        this.#value = Signal.evaluate(this, this.evaluate, this);\n        if (!hasInvalidDependency) this.#valid = true;\n        return this.#value;\n    }\n\n    set value(value) {\n        // Don't update for no change in value.\n        if(this.#value === value) return;\n\n        const { object, name } = this;\n\n        // Set value on object and update value from object in case target is\n        // doing something funky with property descriptors that return a\n        // different value from the value set.\n        object[name] = value;\n        value = object[name];\n\n        // Don't invalidate for no change in value.\n        if(this.#value === value) return;\n\n        // Set cache by reading value back off the object in case object is\n        // doing something funky with property descriptors that return a\n        // different value from the value that was set. Rare, but it can happen.\n        this.#value = value;\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble but #valid is true and #value is set so\n        // that's ok I think?\n        invalidateDependents(this);\n    }\n\n    /*\n    .invalidate(signal)\n    Invalidates this signal and calls `.invalidate(this)` on all dependent\n    signals. The `signal` parameter is the signal causing the invalidation; it\n    may be `undefined`: where it exists it is verified as a current input of\n    this before this is invalidated.\n    */\n\n    invalidate(signal) {\n        if (!this.#valid) return;\n\n        // Verify that signal has the right to invalidate this to protect us\n        // against the case where a dependent is left on another signal due to\n        // an old evaluation\n        if (signal && !hasInput(this, signal)) return;\n\n        this.#valid = false;\n\n        // Clear inputs\n        clearInputs(this);\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble, as it would evaluate and cache this signal\n        // and overwrite dependents before we have finished invalidating\n        // this set of dependents.\n        invalidateDependents(this);\n    }\n}\n\n\n/*\nComputeSignal(value)\n*/\n\nclass ComputeSignal extends Signal {\n    // Privates\n    #fn;\n    #context;\n    #valid;\n    #value;\n\n    constructor(fn, context) {\n        super();\n        this.#fn      = fn;\n        this.#context = context;\n    }\n\n    /**\n    .value\n    Getting `.value` gets a cached value or, if the signal is invalid,\n    evaluates (and caches) value from `fn()`. During evaluation this signal is\n    registered as dependent on other signals whose value is got.\n    **/\n\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal, irrespective of state of #value\n        if (evaluatingSignal) setDependency(this, evaluatingSignal);\n        if (this.#valid) return this.#value;\n        this.#value = Signal.evaluate(this, this.#fn, this.#context);\n        if (!hasInvalidDependency) this.#valid = true;\n        return this.#value;\n    }\n\n    /*\n    .invalidate(signal)\n    Invalidates this signal and calls `.invalidate(this)` on all dependent\n    signals. The `signal` parameter is the signal causing the invalidation; it\n    may be `undefined`: where it exists it is verified as a current input of\n    this before this is invalidated.\n    */\n\n    invalidate(signal) {\n        if (!this.#valid) return;\n\n        // Verify that signal has the right to invalidate this to protect us\n        // against the case where a dependent is left on another signal due to\n        // an old evaluation\n        if (signal && !hasInput(this, signal)) return;\n\n        this.#valid = false;\n\n        // Clear inputs\n        clearInputs(this);\n\n        // Invalidate dependents. If a dependent updates synchronously here\n        // we may be in trouble, as it would evaluate and cache this signal\n        // and overwrite dependents before we have finished invalidating\n        // this set of dependents.\n        invalidateDependents(this);\n    }\n}\n\n\n/**\nTimedSignal(name, object)\nA signal that wraps an AudioParam and remains invalid until a specified time in\nthe future. This ensures that any FrameSignal signals that depend on it keep\nrendering until automation completes.\n**/\n\nexport class TimedSignal extends Signal {\n    #validTime = 0;\n\n    constructor(name, object) {\n        super(name);\n        this.object = object;\n    }\n\n    getTime() {\n        return window.performance.now();\n    }\n\n    evaluate() {\n        return this.object[this.name];\n    }\n\n    /**\n    .value\n    Getting `.value` gets the object's value. If there's an evaluating signal,\n    it becomes dependent on this ParamSignal. The signal remains invalid until\n    the `.getTime()` reaches `.invalidateUntil(time)` time.\n    **/\n    get value() {\n        // If there is a signal currently evaluating then it becomes a\n        // dependency of this signal\n        if (Signal.evaluating) {\n            setDependency(this, evaluatingSignal);\n\n            // This is a timed signal, therefore may remain invalid following an\n            // evaluation. We can't invalidate the graph while evaluating, but\n            // the invalid state must prevent dependents from becoming valid...\n            // ...so set a flag marking the current evaluation as invalid\n            if (this.getTime() < this.#validTime) hasInvalidDependency = true;\n        }\n\n        // Get the current value from the audio param\n        return this.evaluate();\n    }\n\n    // DEPRECATE\n    set value(value) {\n        console.warn('Dont really want to be setting value of TimedSignal');\n        console.trace();\n\n        // Don't update for no change in value.\n        if(this.object[this.name] === value) return;\n\n        // Update value and invalidate until now\n        this.object[this.name] = value;\n        invalidateUntil(this.getTime());\n    }\n\n    /**\n    .invalidateUntil(time)\n    Sets a time at which this signal becomes valid. Until this time is reached\n    the signal remains invalid, causing dependent observer signals to keep\n    observing.\n    **/\n    invalidateUntil(time) {\n        // Don't do anything if the #validTime isn't changing ... Hmmm ... see\n        // below. I think this condition suffers the same problem.\n        //if (time === this.#validTime) return;\n\n        const currentTime = this.getTime();\n        const isValid     = currentTime >= this.#validTime;\n\n        // Update the #validTime\n        this.#validTime = time;\n\n        // If we are moving into a valid state do nothing ... Hmmmmmm ...\n        // This condition interferes with being able to invalidate a time in the\n        // past, which we may want to do for example for latency compensation.\n        // If we are calling .invalidateUntil(), I think we can assume something\n        // has changed and we need to invalidate unless we were already invalid.\n        //if (currentTime > time) return;\n\n        // If we are moving out of a valid state invalid dependents\n        if (isValid) invalidateDependents(this);\n    }\n}\n\n\n/*\nObserver(evaluate)\nAn Observer is a signal that schedules it's own evaluation. It calls `evaluate`\non construction and again on every cue following an invalidation of any signal\nread by `evaluate`. Internal only, sub-classed by `TickSignal` and `FrameSignal`.\n*/\n\nclass Observer extends Signal {\n    constructor(fn) {\n        super();\n\n        if (DEBUG) {\n            this.id = ++id;\n            console.log(\n                '%cSignal%c create%c ' + this.constructor.name + '#' + this.id + (this.name ? ' \"' + this.name + '\"' : ''),\n                'color: #718893; font-weight: 300;',\n                'color: #3896BF; font-weight: 300;',\n                'color: #718893; font-weight: 300;'\n            );\n        }\n\n        // Check we are not currently evaluating. This would be bad because an\n        // evaluation is ephemereal – it may run again, leaving this signal in\n        // memory yet superseded by the one created in the latest evaluation.\n        if (evaluatingSignal) {\n            // ------------------------ Experimental ---------------------------\n            // We can set this as an input of evaluatingSignal. this will never\n            // invalidate evaluatingSignal – it has no mechanism to do so – but\n            // when evaluatingSignal is invalidated this will be stopped.\n            let n = 0;\n            while (evaluatingSignal[--n]) if (evaluatingSignal[n] === this) break;\n            evaluatingSignal[n] = this;\n            // -----------------------------------------------------------------\n\n            // The old way was to throw an error.\n            // Make recovery possible? I'm not convinced this works in all cases\n            // but it works where an observer is instantiated inside an observer\n            //evaluatingSignal = undefined;\n            //throw new Error('Illegal nested ' + this.constructor.name + ' – cannot instantiate observer during signal evaluation');\n        }\n\n        // If no fn passed in we do not want to evaluate the signal immediately.\n        // This provides for a sub-class to define .evaluate() and launch it\n        // when it likes, as in Literal's Renderer.\n        if (!fn) return;\n\n        // Set fn as evaluation function\n        this.evaluate = fn;\n\n        // An initial, synchronous evaluation binds this observer to changes\n        if (Signal.evaluate(this, this.evaluate) || hasInvalidDependency) this.cue();\n    }\n\n    invalidate(input) {\n        // Static observers list\n        const observers = this.constructor.observers;\n\n        // If the observer is already cued do nothing\n        if (observers.indexOf(this) !== -1) return;\n\n        // Verify that input signal has the right to invalidate this\n        if (input && !hasInput(this, input)) return;\n\n        // Clear inputs\n        clearInputs(this);\n\n        this.cue();\n    }\n\n    stop() {\n        // Remove this from signal graph\n        let n = 0, input;\n        while (input = this[--n]) {\n            let m = -1;\n            this[n] = undefined;\n            // --------------------- Experimental ------------------------------\n            // A stopable signal has no output\n            if (input.stop) input.stop();\n            // -----------------------------------------------------------------\n            else removeOutput(input, this);\n        }\n\n        // Remove from observers if cued\n        const observers = this.constructor.observers;\n        const i = observers.indexOf(this);\n        if (i !== -1) {\n            // You cannot do this during a render cycle\n            if (observers === rendering) throw new Error('Attempt to remove observer while observers is rendering');\n            observers.splice(i, 1);\n        }\n        return this;\n    }\n\n    valueOf()  { return this; }\n    toString() { return '[object Signal]' ; }\n    toJSON()   { return; }\n}\n\nlet rendering;\n\nfunction render(observers) {\n    let n = -1, signal;\n\n    rendering = observers;\n    while (signal = observers[++n]) {\n        // Evaluate the signal, if it returns false-y, and nothing has flagged\n        // it as having invalid dependencies...\n        if (!Signal.evaluate(signal, signal.evaluate) && !hasInvalidDependency) {\n            // ...remove the signal from observers and decrement n\n            observers.splice(n--, 1);\n        }\n    }\n    rendering = undefined;\n    return observers;\n}\n\n\n/*\nTickSignal\nA TickSignal is a signal that calls `fn` on construction and again on every\ntick following an invalidation of any signal read by `fn`. Use `Signal.tick(fn)`.\n*/\n\nconst promise = Promise.resolve();\n\nfunction tick() {\n    const observers = render(TickSignal.observers);\n\n    // Where observers remain schedule the next tick\n    if (observers.length) promise.then(tick);\n}\n\nexport class TickSignal extends Observer {\n    static observers = [];\n\n    cue() {\n        const observers = this.constructor.observers;\n\n        // If no observers are cued, cue tick() on the next tick\n        if (!observers.length) promise.then(tick);\n\n        // Add this observer to observers\n        observers.push(this);\n    }\n}\n\n\n/*\nFrameSignal\n\nA FrameSignal is an observer signal that calls `fn` on construction and again\non every animation frame following an invalidation of any signal read by `fn`.\nAdditionally where the return value of `fn()` is truthy the signal remains\nactive and will evaluate on following frames until `fn()` is false-y.\n\nUse `Signal.frame(fn)` to create a FrameSignal signal.\n*/\n\nfunction frame() {\n    const observers = render(FrameSignal.observers);\n\n    // Where observers remain schedule the next frame\n    if (observers.length) requestAnimationFrame(frame);\n}\n\nexport class FrameSignal extends Observer {\n    static observers = [];\n\n    cue() {\n        const observers = this.constructor.observers;\n\n        // If no observers are cued, cue frame() on the next frame\n        if (!observers.length) window.requestAnimationFrame(frame);\n\n        // Add this observer to observers\n        observers.push(this);\n    }\n}\n", "\n/**\nexec(regex, fn, string)\nCalls `fn` with the result of `regex.exec(string)` if that result is not null,\nand returns the resulting value.\n**/\n\nimport curry from './curry.js';\n\nexport function exec(regex, fn, string) {\n    let data;\n\n    // If string looks like a regex result, get rest of string\n    // from latest index\n    if (typeof string !== 'string' && string.input !== undefined && string.index !== undefined) {\n        data = string;\n        string = data.input.slice(\n            string.index\n            + string[0].length\n            + (string.consumed || 0)\n        );\n    }\n\n    // Look for tokens\n    const tokens = regex.exec(string);\n    if (!tokens) { return; }\n\n    const output = fn(tokens);\n\n    // If we have a parent tokens object update its consumed count\n    if (data) {\n        data.consumed = (data.consumed || 0)\n            + tokens.index\n            + tokens[0].length\n            + (tokens.consumed || 0) ;\n    }\n\n    return output;\n}\n\nexport default curry(exec, true);\n", "\nimport curry from './curry.js';\nimport { exec } from './exec.js';\n\nfunction error(regex, reducers, string) {\n    if (string.input !== undefined && string.index !== undefined) {\n        string = string.input;\n    }\n\n    throw new Error('Cannot parse string \"' + (string.length > 128 ? string.length.slice(0, 128) + '…' : string) + '\"');\n}\n\nfunction reduce(reducers, acc, tokens) {\n    let n = -1;\n\n    while (++n < tokens.length) {\n        acc = (tokens[n] !== undefined && reducers[n]) ? reducers[n](acc, tokens) : acc ;\n    }\n\n    // Call the optional done fn\n    return reducers.done ? reducers.done(acc, tokens) :\n        // Support the old .close() name\n        reducers.close ? reducers.close(acc, tokens) :\n        // Return the result\n        acc ;\n}\n\n/**\ncapture(regex, reducers, accumulator, string)\nParse `string` with `regex`, calling functions in `reducers` to modify\nand return `accumulator`.\n\nReducers is an object of functions keyed by the index of their capturing\ngroup in the regexp result (`0` corresponding to the entire regex match,\nthe first capturing group being at index `1`). Reducer functions are\ncalled in capture order for all capturing groups that captured something.\nReducers may also define the function 'done', which is called at the end\nof every capture. All reducer functions are passed the paremeters\n`(accumulator, tokens)`, where `tokens` is the regexp result, and are expected\nto return a value that is passed as an accumulator to the next reducer function.\n\nReducers may also define a function `'catch'`, which is called when a match\nhas not been made (where `'catch'` is not defined an error is thrown).\n\n```js\nconst parseValue = capture(/^\\s*(-?\\d*\\.?\\d+)(\\w+)?\\s*$/, {\n    // Create a new accumulator object each call\n    0: () => ({}),\n\n    1: (acc, tokens) => {\n        acc.number = parseFloat(tokens[1]);\n        return acc;\n    },\n\n    2: (acc, tokens) => {\n        acc.unit = tokens[2];\n        return acc;\n    }\n}, null);\n\nconst value = parseValue('36rem');    // { number: 36, unit: 'rem' }\n```\n*/\n\nexport function capture(regex, reducers, acc, string) {\n    const output = exec(regex, (tokens) => reduce(reducers, acc, tokens), string);\n\n    // If tokens is undefined exec has failed to apply regex to string\n    return output === undefined ?\n        // If there is a catch function, call it, otherwise error out\n        reducers.catch ?\n            reducers.catch(acc, string) :\n            error(regex, reducers, string) :\n\n        // Return the accumulator\n        output ;\n}\n\nexport default curry(capture, true);\n", "\n\nimport create from '../create.js';\n\nconst $internals = Symbol('internals');\n\n// TODO: No longer needed polyfill for Safari... ??\n/*\nfunction attachInternals(element) {\n    var internals;\n\n    // Use native attachInternals where it exists and we have the right to use\n    // it - you cannot attachInternals to customised built-ins\n    if (element.attachInternals && !element.getAttribute('is')) {\n        return element.attachInternals();\n        //if (internals.setFormValue) return internals;\n    }\n    else {\n        internals = {\n            shadowRoot: elem.shadowRoot\n        };\n    }\n\n    // Otherwise polyfill it with a pseudo internals object, actually a hidden\n    // input that we put inside element (but outside the shadow DOM). We may\n    // not yet put this in the DOM however – it violates the spec to give a\n    // custom element children before it's contents are parsed. Instead we\n    // wait until connectCallback.\n    //internals.polyfillInput = create('input', { type: 'hidden', name: elem.name });\n    //elem.appendChild(internals.polyfillInput);\n    // Polyfill internals object setFormValue\n    //internals.setFormValue = function(value) {\n    //    this.input.value = value;\n    //};\n\n    return internals;\n}\n\nexport function createInternals(Element, element, shadow) {\n    return (element[$internals] = Element.formAssociated ?\n        attachInternals(element) :\n        { shadowRoot: shadow }\n    );\n}\n*/\n\nexport function createInternals(Element, element, shadow) {\n    return element[$internals] = (element.attachInternals && !element.getAttribute('is')) ?\n        element.attachInternals() :\n        { shadowRoot: shadow } ;\n}\n\nexport function getInternals(element) {\n    return element[$internals];\n}\n", "\n/**\nelement(tag, lifecycle, properties, stylesheet, message)\n\nRegisters a custom element `tag` and returns its constructor.\n\n- `tag`: A string in the form `'custom-name'`, `'<custom-name>'`,\n`'tag is=\"custom-name\"'` or `'<tag is=\"custom-name\">'`\n- `lifecycle`: `{\n    mode:       'open' or 'closed'\n    focusable:  true or false\n    shadow:     html string or '#template-id' or fragment\n\n    // Styleheet\n    stylesheet: optional string path to stylesheet for shadow DOM\n\n    // Lifecycle handlers\n    construct:  called during element construction\n    connect:    called when element added to DOM\n    load:       called when stylesheet loaded\n    disconnect: called when element removed from DOM\n\n    // Form elements\n    enable:     called when form element enabled\n    disable:    called when form element disabled\n    reset:      called when form element reset\n    restore:    called when form element restored\n}`\n- `properties`: `{\n    name: {\n        construct: fn called before lifecycle.construct\n        attribute: fn called on `element.setAttribute('name', ...)`\n        set:       fn called on setting property 'name'\n        get:       fn called on getting property 'name'\n    }\n}`\n- `stylesheet`: url of a stylesheet to load in to the shadow DOM\n- `message`: optional debug message to logged when element is registered\n\nThe name form `'tag is=\"element-name\"'` creates customised built-in elements in\nbrowsers that support the feature. Safari does not, but support is somewhat\npolyfilled. Mileage will vary.\n\n#### Lifecycle\n\nLifecycle handlers are called with the element as `this` and with the parameters\n`shadow` and `internals`.\n\nOn initialisation the `construct` handler is called. Set up the shadow root and\ndefine event handlers here. Children and attributes must not be inspected or\nassigned at this point: doing so will throw an error when constructed via\n`document.createElement()`.\n\nFollowing that, attribute handlers in `properties` are called for attributes\ndeclared in the HTML. The HTML parser normally calls these in source order.\n\nThen the `connect` handler is called when the element is placed in the DOM, or\nif it is already in the DOM and is being upgraded.\n\nBoth `load` and `slotchange` are asynchronous. Things get a little tricky here.\nThe order of `load` callbacks and `'slotchange'` listeners cannot be guaranteed\nin Safari. When there is an empty cache `slotchange` comes first, as it always\ndoes in other browsers, otherwise `load` happens first.\n\nWhere there is a stylesheet loading, most browsers call `'slotchange'` listeners\n(asynchronously) before `load` – except Safari, where if the stylesheet is\nalready cached `load` is called before `'slotchange'` listeners. (TODO: I would\nlike to guarantee `slotchange` before `load`, but it is not clear how to delay\n`load`... if there is no slotted content, `slotchange` may not be called at\nall...)\n\nFinally, `connect` and `disconnect` are called whenever the element is inserted\ninto or removed from the DOM.\n\nThe effects of the `mode` option are subtle. In 'closed' mode, the element is\nnot given a publicly accessible `shadowRoot` property, and events that traverse\nthe shadow boundary are retargeted (as they are in 'open' mode) but also have\ntheir `path` list truncated.\n\n### Properties\n\nWhere the `properties` object contains a definition for a `value` property, work\nis done to give the element form field behaviour. The constructor is assigned\nthe property `formAssociated` which signals to the browser that it constructs\nform fields. Where they are not defined in `properties` the prototype is\nassigned default handlers for the standard properties `type`, `name`, `form`,\n`labels`, `validity`, `validationMessage`, `willValidate`, `checkValidity`\nand `reportValidity`. Form behaviour is also mildly polyfilled in browsers\nwithout support by inserting a hidden input inside the element but outside the\nshadow DOM. Mileage will vary. Managing focus can be problematic without browser\nsupport.\n*/\n\nimport capture  from 'fn/capture.js';\nimport id       from 'fn/id.js';\nimport noop     from 'fn/noop.js';\nimport overload from 'fn/overload.js';\nimport create   from './create.js';\nimport { createInternals, getInternals } from './element/internals.js';\n\n\nconst define         = Object.defineProperties;\nconst nothing        = {};\nconst constructors   = {};\nconst formProperties = {\n    // These properties echo those provided by native form controls. They are\n    // not strictly required, but provided for consistency with standard form\n    // elements.\n\n    //type: { value: 'text' },\n\n    name: {\n        set: function(name) { return this.setAttribute('name', name); },\n        get: function()     { return this.getAttribute('name') || ''; }\n    },\n\n    form:              { get:   function() { return getInternals(this).form; }},\n    labels:            { get:   function() { return getInternals(this).labels; }},\n    validity:          { get:   function() { return getInternals(this).validity; }},\n    validationMessage: { get:   function() { return getInternals(this).validationMessage; }},\n    willValidate:      { get:   function() { return getInternals(this).willValidate; }},\n    checkValidity:     { value: function() { return getInternals(this).checkValidity(); }},\n    reportValidity:    { value: function() { return getInternals(this).reportValidity(); }}\n};\n\n\nlet supportsCustomisedBuiltIn = false;\n\n\n// Capture name and tag from <element-name> or <tag is=\"element-name\">, syntax\n// brackets and quotes optional\nconst parseNameTag = capture(/^\\s*<?([a-z][\\w]*-[\\w-]+)>?\\s*$|^\\s*<?([a-z][\\w]*)\\s+is[=\\s]*[\"']?([a-z][\\w]*-[\\w-]+)[\"']?>?\\s*$/, {\n    1: (data, captures) => ({\n        name: captures[1]\n    }),\n\n    2: (data, captures) => ({\n        name: captures[3],\n        tag:  captures[2]\n    }),\n\n    catch: function(data, name) {\n        throw new SyntaxError('dom element() – name must be of the form \\'element-name\\' or \\'tag is=\"element-name\"\\' (' + name + ')')\n    }\n}, null);\n\nconst onceEvent = { once: true };\n\nfunction toLoadPromise(element) {\n    return !!element.sheet ?\n        // Link has already loaded\n        Promise.resolve({ target: element }) :\n        // Wait for load\n        new Promise((resolve, reject) => {\n            element.addEventListener('load', resolve, onceEvent);\n            element.addEventListener('error', reject, onceEvent);\n        }) ;\n}\n\nfunction stop(object) {\n    object.stop();\n}\n\nfunction getElementConstructor(tag) {\n    if (constructors[tag]) return constructors[tag];\n\n    const constructor = document.createElement(tag).constructor;\n    if (constructor === HTMLUnknownElement) {\n        throw new Error('Cannot define customised built-in - constructor for <' + tag + '> is HTMLUnknownElement');\n    }\n\n    return constructors[tag] = constructor;\n}\n\nfunction transferProperty(element, key) {\n    if (element.hasOwnProperty(key)) {\n        const value = element[key];\n        delete element[key];\n        element[key] = value;\n    }\n    return element;\n}\n\nfunction createShadow(elem, options) {\n    // Create a shadow root. Shadows may be 'open' or 'closed'. Closed shadows\n    // are not exposed via element.shadowRoot, and events propagating from\n    // inside of them report the element as target. Default to 'closed'.\n    const shadow = elem.attachShadow({\n        mode:           options.mode || 'closed',\n        delegatesFocus: options.focusable || false\n    });\n\n    if (options.stylesheet) {\n        const link = create('link', { rel: 'stylesheet', href: options.stylesheet });\n        shadow.append(link);\n    }\n\n    return shadow;\n}\n\nfunction fillShadowFromTemplate(shadow, template) {\n    // It's a string\n    if (typeof template === 'string') {\n        // It's an id of a template\n        if (template[0] === '#') {\n            shadow.appendChild(\n                document.getElementById(template.slice(1))\n                .content.clone(true)\n            );\n        }\n        // It's html\n        else {\n            shadow.innerHTML = template;\n        }\n    }\n    // It's a <template>\n    else {\n        shadow.appendChild(template.content.clone(true));\n    }\n\n    return shadow;\n}\n\nfunction isNotUpgraded(element) {\n    /* Detect marked as upgraded, mark if not */\n    const upgraded = element.isUpgraded;\n    element.isUpgraded = true;\n    return !upgraded;\n}\n\nfunction findByIs(root, name) {\n    return Array\n    .from(root.querySelectorAll('[is=\"' + name + '\"]'))\n    .filter(isNotUpgraded);\n}\n\nconst createDescriptor = overload((name, options) => typeof options, {\n    object:   (name, descriptor) => descriptor,\n    function: (name, fn) => ({ value: fn }),\n    default:  (name, options) => {\n        throw new TypeError('element() does not accept property descriptor of type ' + typeof options);\n    }\n});\n\nexport default function element(definition, lifecycle = {}, properties = {}, log = '') {\n    const { name, tag } = parseNameTag(definition);\n\n    // Get the element constructor or the base HTMLElement constructor\n    const constructor = typeof tag === 'string' ?\n        getElementConstructor(tag) :\n        HTMLElement ;\n\n    // Split properties into attributes and property descriptors\n    const attributes  = [];\n    const descriptors = {};\n\n    let propname, descriptor;\n    for (propname in properties) {\n        descriptor = createDescriptor(propname, properties[propname]);\n\n        // Add name to list of observed attributes\n        if (descriptor.attribute) attributes.push(propname);\n\n        // Add descriptor to properties to be defined\n        if (descriptor.set || descriptor.get || 'value' in descriptor) descriptors[propname] = descriptor;\n\n        // Override property descriptor\n        properties[propname] = descriptor;\n    }\n\n    // Declare constructor\n    function Element() {\n        // Construct an instance from Constructor using Element prototype\n        const element = Reflect.construct(constructor, arguments, Element);\n\n        // Make shadow if mode or shadow have been set\n        const shadow = (lifecycle.mode || (typeof lifecycle.shadow === 'string')) ?\n            createShadow(element, lifecycle) :\n            undefined ;\n\n        // Fill shadow with template\n        if (lifecycle.shadow) fillShadowFromTemplate(shadow, lifecycle.shadow);\n\n        // Get access to the internals object. If form associated, internals is\n        // the form control API internals object. We're gonna be rude and\n        // extend it.\n        const internals = createInternals(Element, element, shadow);\n\n        // Flag support for custom built-ins. We know this when tag exists and\n        // Element constructor is called\n        if (tag) supportsCustomisedBuiltIn = true;\n        if (lifecycle.construct) lifecycle.construct.call(element, shadow, internals);\n\n        // At this point, if properties have been set before the element was\n        // upgraded they already exist on the element itself, where we have\n        // just upgraded it's protytype to define those properties. Those\n        // definitions will never be reached. Either:\n        //\n        // 1. Define properties on the instance instead of the prototype, as in\n        //    Object.defineProperties(element, descriptors) here in the\n        //    constructor. Won't actually solve the problem.\n        //\n        // 2. Take a great deal of care when authoring not to set properties\n        //    before an element is upgraded. We can't impose a restriction like\n        //    that on Joe Bloggs front end developer.\n        //\n        // 3. Copy defined properties to their prototype handlers and delete\n        //    them on the instance.\n        //\n        // Let's go with 3. I'm not happy we have to do this, though.\n        Object.keys(descriptors).reduce(transferProperty, element);\n\n        return element;\n    }\n\n    // Set prototype and define properties\n    Element.prototype = Object.create(constructor.prototype, descriptors);\n\n    // Prefetch stylesheet ??\n    /*if (stylesheet) {\n        toPrefetchPromise(stylesheet);\n        log = window.DEBUG ?\n            log + ' – stylesheet ' + stylesheet :\n            log ;\n    }*/\n\n    if (properties.value) {\n        // Flag the Element class as formAssociated\n        Element.formAssociated = true;\n\n        // Define standard form properties\n        define(Element.prototype, formProperties);\n\n        if (lifecycle.enable || lifecycle.disable) {\n            Element.prototype.formDisabledCallback = function(disabled) {\n                const internals = getInternals(this);\n                return disabled ?\n                    lifecycle.disable && lifecycle.disable.call(this, internals.shadowRoot, internals) :\n                    lifecycle.enable && lifecycle.enable.call(this, internals.shadowRoot, internals) ;\n            };\n        }\n\n        if (lifecycle.reset) {\n            Element.prototype.formResetCallback = function() {\n                const internals = getInternals(this);\n                return lifecycle.reset.call(this, internals.shadowRoot, internals);\n            };\n        }\n\n        if (lifecycle.restore) {\n            Element.prototype.formStateRestoreCallback = function() {\n                const internals = getInternals(this);\n                return lifecycle.restore.call(this, internals.shadowRoot, internals);\n            };\n        }\n    }\n\n    // Attributes\n    if (attributes.length) {\n        Element.observedAttributes = attributes;\n        Element.prototype.attributeChangedCallback = function(name, old, value) {\n            return properties[name].attribute.call(this, value) ;\n        };\n    }\n\n    // Lifecycle\n    if (lifecycle.connect) {\n        Element.prototype.connectedCallback = function() {\n            const internals = getInternals(this);\n            const shadow    = internals.shadowRoot;\n\n            // Connect\n            internals.stopable = lifecycle.connect.call(this, shadow, internals);\n\n            // Avoid flash of unstyled content in shadow DOMs that must load assets.\n            // Now, it's debatable whether this code should be here or in the constructor.\n            // Whether links in the shadow may have already emitted load events by connect\n            // time. They'd have to have done it synchronously, so I don't think so.\n            if (!shadow) return;\n\n            const links = shadow.querySelectorAll('link[rel=\"stylesheet\"]');\n\n            if (links.length) {\n                // Hide all content other than the default slot until stylesheets\n                // have loaded. We keep the default slot visible as that content\n                // was visible before upgrade and we do not want it to momentarily\n                // disappear.\n                const style = create('style', '*:not(slot), slot:not([name]) { display: none !important; }');\n                shadow.prepend(style);\n\n                let promise;\n                if (!internals.loadPromise) {\n                    // Wait for stylesheets to load\n                    promise = internals.loadPromise = Promise.all(Array.from(links, toLoadPromise));\n                }\n                else {\n                    // Insert an animation frame to avoid flash on reconnect\n                    promise = internals.loadPromise.then(() => new Promise(requestAnimationFrame));\n                }\n\n                promise.finally(() => {\n                    if (window.DEBUG) window.console.log('%c<' + (tag ? tag + ' is=' + name + '' : name) + '>%c load \\n' + Array.from(links).map((link) => link.href.replace(/https?:\\/\\//, '')).join('\\n'), 'color:#3a8ab0;font-weight:400;', 'color:#888888;font-weight:400;');\n                    // Remove hide style\n                    style.remove();\n                    // and call the load() callback\n                    if (lifecycle.load) lifecycle.load.call(this, shadow, internals);\n                });\n            }\n            else if (lifecycle.load) {\n                lifecycle.load.call(this, shadow, internals);\n            }\n        }\n    }\n\n    Element.prototype.disconnectedCallback = function() {\n        const internals = getInternals(this);\n        if (internals.stopable) {\n            // Support a stopable...\n            if (internals.stopable.stop) { internals.stopable.stop(); }\n            // or an array of stopables\n            else { internals.stopable.forEach(stop); }\n        }\n        if (lifecycle.disconnect) lifecycle.disconnect.call(this, internals.shadowRoot, internals);\n    };\n\n    // Log registration to console\n    window.console &&\n    window.console.log('%c<' + (tag ? tag + ' is=' + name + '' : name) + '>%c ' + log, 'color:#3a8ab0;font-weight:600;', 'color:#888888;font-weight:400;');\n\n    // Define the element\n    window.customElements.define(name, Element, tag && { extends: tag });\n\n\n    // Safari partial polyfill.\n    // Where tag is supplied, element should have been registered as a customised\n    // built-in and the constructor would have run if any were in the DOM already.\n    // However, Safari does not support customised built-ins. Here we attempt to\n    // go some way towards filling in support by searching for elements and\n    // assigning their intended APIs to them.\n    if (tag && !supportsCustomisedBuiltIn) {\n        // It may be there were none in the DOM, in which case we must run a\n        // test. Not ideal.\n        const div = document.createElement('div');\n        div.style.position = 'fixed';\n        div.style.left = '-1000px';\n        div.style.top  = '-1000px';\n        div.innerHTML = '<' + tag + ' is=\"' + name + '\"></' + tag + '>';\n        document.body.append(div);\n        div.remove();\n\n        if (!supportsCustomisedBuiltIn) {\n            if (window.DEBUG) {\n                console.warn('Browser does not support customised built-in elements, polyfilling <' + tag + ' is=\"' + name + '\">');\n            }\n\n            function upgrade(element) {\n                // Store values of properties we are about to define\n                const store = {};\n                Object.keys(descriptors).forEach((key) => {\n                    if (element[key] !== undefined) store[key] = element[key];\n                });\n\n                // Define properties on element\n                define(element, descriptors);\n\n                // Construct an instance from Constructor using the Element prototype\n                const shadow = lifecycle.mode || lifecycle.shadow ?\n                    createShadow(element, lifecycle) :\n                    undefined ;\n\n                // Get access to the internals object\n                const internals = createInternals(Element, element, shadow);\n\n                // Run constructor\n                lifecycle.construct && lifecycle.construct.call(element, shadow, internals);\n\n                if (window.DEBUG) {\n                    // Assign stored properties back onto element\n                    try {\n                        Object.assign(element, store);\n                    }\n                    catch(e) {\n                        console.warn(e.message, tag, Object.keys(store));\n                    }\n                }\n                else {\n                    Object.assign(element, store);\n                }\n\n                // Detect and run attributes\n                let n = -1, name;\n                while (name = attributes[++n]) {\n                    // elements.attributes is sometimes undefined... why?\n                    const attribute = element.attributes[name];\n                    if (attribute) properties[name].attribute.call(element, attribute.value);\n                }\n\n                // Run connected callback\n                lifecycle.connect && lifecycle.connect.call(element, shadow, internals);\n            }\n\n            function polyfillByRoot(root) {\n                findByIs(root, name).forEach(upgrade)\n                const observer = new MutationObserver(() => findByIs(root, name).forEach(upgrade));\n                observer.observe(root, { childList: true, subtree: true });\n            }\n\n            // Expose on element for use in shadow DOMs\n            Element.polyfillByRoot = polyfillByRoot;\n\n            // Run on document automatically\n            polyfillByRoot(document);\n        }\n        else {\n            Element.polyfillByRoot = noop;\n        }\n    }\n    else {\n        Element.polyfillByRoot = noop;\n    }\n\n    return Element;\n}\n\nexport { getInternals };\n", "/**\ntoType(object)\nReturns `typeof object`.\n*/\n\nexport default (object) => typeof object;\n", "\nimport id       from '../id.js';\nimport overload from '../overload.js';\nimport toType   from '../to-type.js';\n\n\nconst define = Object.defineProperties;\nconst call = overload(toType, {\n    function: (fn) => fn(),\n    object:   (object) => object.stop()\n});\n\n\n/** Stopable() **/\n\nexport default class Stopable extends id {\n    #stopables;\n\n    /**\n    .stop()\n    Stops the stream, passing any parameters up to the head of the stream. The\n    head determines whether the stream stops immediately or asynchronously.\n    **/\n    stop() {\n        // Check we are not already done\n        if (this.status === 'done') return this;\n\n        // Set status\n        this.status = 'done';\n\n        // Call done functions and stopables\n        const stopables = this.#stopables;\n        this.#stopables = undefined;\n        if (stopables) stopables.forEach(call);\n\n        // Make it chain-able\n        return this;\n    }\n\n    /**\n    .done(fn)\n    Cues `fn` to be called when the stream is stopped. If `fn` is an object, it\n    must have a `.stop()` method, which is called when this is stopped.\n    **/\n    done(fn) {\n        // Is stream already stopped? Call listener immediately.\n        if (this.status === 'done') {\n            call(listener);\n            return this;\n        }\n\n        // Add to done handlers\n        const stopables = this.#stopables || (this.#stopables = []);\n        stopables.push(fn);\n\n        // Make it chain-able\n        return this;\n    }\n}\n\ndefine(Stopable.prototype, {\n    status: { writable: true }\n});\n", "\nimport noop       from '../noop.js';\nimport overload   from '../overload.js';\nimport toType     from '../to-type.js';\nimport Stopable   from './stopable.js';\n\n\nconst assign = Object.assign;\nconst create = Object.create;\n\n\nfunction throwTypeError(source) {\n    throw new TypeError('Stream cannot be created .from() ' + typeof source);\n}\n\nfunction push(stream, value) {\n    if (value === undefined) return;\n    let n = -1;\n    while (stream[++n]) stream[n].push(value);\n    return stream;\n}\n\nfunction stop(stream) {\n    // Call done functions and listeners\n    Stopable.prototype.stop.apply(stream);\n\n    // Loop through outputs, propagate stop() down the pipe\n    let o = -1, output;\n    while (output = stream[++o]) {\n        // Remove output from stream\n        stream[o] = undefined;\n        // If output is not stop-able it never got stream as an input\n        if (!output.stop) continue;\n        // Remove stream from output's inputs\n        removeInput(output, stream);\n        // If output has no inputs left, stop it\n        if (!output[-1]) output.stop();\n    }\n\n    return stream;\n}\n\nfunction removeInput(stream, input) {\n    // Remove input from stream\n    let i = 0;\n    while (stream[--i] && stream[i] !== input);\n    while (stream[i--]) stream[i + 1] = stream[i];\n}\n\nfunction removeOutput(stream, output) {\n    // Remove output from stream\n    let o = -1;\n    while (stream[++o] && stream[o] !== output);\n    while (stream[o++]) stream[o - 1] = stream[o];\n}\n\nfunction unpipe(output, input) {\n    // Remove link between streams without stopping them\n    removeInput(input, output);\n    removeOutput(output, input);\n}\n\n\n/* Consumer() */\n\nexport class Consumer extends Stopable {\n    /**\n    .stop()\n    Stops the stream.\n    **/\n    stop() {\n        if (this.status === 'done') return this;\n\n        // Loop through inputs, notify them we are detaching\n        let input;\n        while (input = this[-1]) {\n            // Remove input from this\n            let i = -1;\n            while (this[i--]) this[i + 1] = this[i];\n\n            // Remove this from input's outputs\n            removeOutput(input, this);\n\n            // If input is stop-able and has no other outputs, stop it\n            if (input.stop && !input[0]) input.stop(input);\n        }\n\n        // Set status and call done(fn) handlers\n        return super.stop();\n    }\n}\n\n\n/* Each(fn) */\n\nclass Each extends Consumer {\n    constructor(fn) {\n        super();\n        this.push = fn;\n    }\n}\n\n\n/* Reduce() */\n\nclass Reduce extends Consumer {\n    constructor(fn, accumulator) {\n        super();\n        this.fn    = fn;\n        this.value = accumulator;\n        this.i     = 0;\n    }\n\n    push(value) {\n        const fn = this.fn;\n        this.value = fn(this.value, value, this.i++, this);\n    }\n}\n\n\n/**\nStream(start)\nCreates a stream from a `start` function, called when a consumer is first\nattached, with two arguments, `start(push, stop)`. `push(value)` is called to\nwrite `value` to the stream and `stop()` is called to stop the stream.\n**/\n\nexport default class Stream extends Consumer {\n    /**\n    .start()\n    **/\n    start() {\n        // If this is 'running' or 'done' we need do nothing here\n        if (this.status) return this;\n\n        // Loop through inputs\n        let i = 0, input;\n        inputloop: while (input = this[--i]) {\n            // Loop through input's outputs\n            let o = -1;\n            // If input already has this as an output skip set up\n            while (input[++o]) if (input[o] === this) continue inputloop;\n            // Set this as input's output\n            input[o] = this;\n            // If input is start-able and this is its first consumer, start it,\n            // otherwise assume it is running\n            if (o === 0 && input.start) input.start();\n        }\n\n        return this;\n    }\n\n    stop() {\n        if (this.status === 'done') return this;\n\n        super.stop();\n\n        // Loop through outputs, propagate stop() down the pipe\n        let o = -1, output;\n        while (output = this[++o]) {\n            // Remove output from this\n            this[o] = undefined;\n            // If output is not stop-able it never got this as an input\n            if (!output.stop) continue;\n            // Remove this from output's inputs\n            removeInput(output, this);\n            // If output has no inputs left, stop it\n            if (!output[-1]) output.stop();\n        }\n\n        return this;\n    }\n\n    /**\n    .pipe(stream)\n    Sets up this stream to pipe values into `stream` when started. Starts\n    immediately where `stream` is already running. Returns `stream`.\n    **/\n    pipe(output) {\n        // If output is stop-able set this as its input\n        if (output.stop) {\n            // Guard against this piping twice to output\n            let i = 0;\n            while (output[--i]) if (output[i] === this) break;\n            output[i] = this;\n        }\n\n        // If output is start-able and is not already running wait to start this\n        if (output.start && !(output[0] || output.status === 'running')) {\n            return output;\n        }\n\n        // Start piping right away\n        let o = -1;\n        while (this[++o]) if (this[o] === output) break;\n        this[o] = output;\n        // If output is the first consumer to be added start this\n        if (!o) this.start();\n\n        // Return output\n        return output;\n    }\n\n    /**\n    .each(fn)\n    Consumes the stream, calling `fn(value)` for each piped value. Returns the\n    stream.\n    **/\n    each(fn) {\n        // Start the Consumer immediately\n        return this.pipe(new Each(fn));\n    }\n\n    /**\n    .buffer(...values)\n    Inserts a buffer of values into the start of a stream. Although the buffer\n    is not hot, before it is started .push() may be used to add values to the\n    buffer.\n    **/\n    buffer(...values) {\n        return this.pipe(new BufferStream(values));\n    }\n\n    /**\n    .filter(fn)\n    Filters out values where `fn(value)` is falsy.\n    **/\n    filter(fn) {\n        return this.pipe(new Filter(fn));\n    }\n\n    /**\n    .flatMap(fn)\n    **/\n    flatMap(fn) {\n        return this.pipe(new FlatMap(fn));\n    }\n\n    /**\n    .map(fn)\n    Maps each value in a stream to `fn(value)` and pipes non-`undefined` results\n    downstream.\n    **/\n    map(fn) {\n        return this.pipe(new Map(fn));\n    }\n\n    /**\n    .reduce(fn, initial)\n    Consume the stream, calling `fn(accumulator, value)` for each value in it.\n    Returns the accumulator.\n    **/\n    reduce(fn, accumulator) {\n        return this.pipe(new Reduce(fn, accumulator)).value;\n    }\n\n    /**\n    .scan(fn, initial)\n    Calls `fn(current, value)` for each `value` in the stream. Where `fn`\n    returns a value it is pushed downstream, and `current` assumes that value\n    on the next iteration. Where `fn` returns `undefined` nothing is pushed and\n    `current` remains unchanged.\n    **/\n    scan(fn, initial) {\n        return this.pipe(new Scan(fn, initial));\n    }\n\n    /**\n    .slice(n, m)\n    Returns a stream of the nth to mth values of stream.\n    **/\n    slice(n, m) {\n        return this.pipe(new Slice(n, m));\n    }\n\n    /**\n    .split(n)\n    **/\n    split(n) {\n        return this.pipe(new Split(n));\n    }\n\n    /* Experimental async iterator support for `for await (x of stream)`\n       loops. */\n    [Symbol.asyncIterator] = async function*() {\n        // Buffer for synchronous values\n        const values = [];\n        let push = (value) => values.push(value);\n\n        function setResolve(res, rej) {\n            push = res;\n        }\n\n        this\n        .each((value) => push(value))\n        .done(() => push = noop);\n\n        while (push !== noop) {\n            yield values.length ?\n                // Yield collected synchronous value\n                values.shift() :\n                // Yield next asynchronous value\n                await new Promise(setResolve) ;\n        }\n    }\n\n    static from = overload(toType, {\n        /**\n        Stream.from(fn)\n        Create a pushable map stream from function `fn`.\n        **/\n        function: (fn) => new Map(fn),\n\n        object: (object) =>\n            /**\n            Stream.from(stream)\n            Treat a pipe-able as a stream directly.\n            **/\n            typeof object.pipe === 'function' ? object :\n\n            /**\n            Stream.from(promise)\n            Create a read-only stream from a promise. The stream is stopped when\n            the promise resolves or rejects.\n            **/\n            typeof object.then === 'function' ? new PromiseStream(object) :\n\n            /**\n            Stream.from(array)\n            Create a pushable buffer stream from an array or array-like object.\n            **/\n            typeof object.length === 'number' ? new BufferStream(Array.from(object)) :\n\n            // object cannot be made into stream\n            throwTypeError(object)\n    });\n\n    /**\n    Stream.of(...values)\n    Create a pushable value or buffer stream from parameter values.\n    **/\n    static of(...values) {\n        return values.length < 2 ?\n            new Value(values[0]) :\n            new BufferStream(values) ;\n    }\n\n    /**\n    Stream.buffer(...values)\n    Create a pushable buffer stream with initial buffer of arguments.\n    **/\n    static buffer(values) {\n        return new BufferStream(values);\n    }\n\n    /**\n    Stream.value(value)\n    Create a pushable value stream with initial `value`.\n    **/\n    static value(value) {\n        return new Value(value);\n    }\n\n    /**\n    Stream.merge(stream1, stream2, ...)\n    Creates a stream by merging values from any number of input streams into a\n    single output stream. Values are emitted in the time order they are received\n    from inputs.\n\n    ```js\n    Stream.merge(stream1, stream2).each((value) => {\n        // value is from stream1 or stream 2\n    });\n    ```\n    **/\n    static merge(...inputs) {\n        return new Merge(inputs);\n    }\n\n    /**\n    Stream.push(stream, value)\n    Pushes `value` to `stream`'s outputs (even on streams that have no `.push()`\n    method). For use in sub-classing Stream.\n    **/\n    static push = push;\n\n    /**\n    Stream.stop(stream)\n    Stops stream, calling `.done()` handlers, setting status to `'done'` and\n    stopping dependent streams. For internal use when sub-classing Stream.\n    **/\n    static stop = stop;\n\n    /*\n    Stream.input(stream, output)\n    Remove output stream from `stream` and vice-versa, without stopping either\n    stream. Normally `stream.stop()` should be used to stop the flow of a pipe -\n    this function is used when making dynamic graphs of streams that need to\n    stay alive.\n    */\n    static unpipe = unpipe;\n\n    static each(fn) {\n        return new Each(fn);\n    }\n\n    static reduce(fn, accumulator) {\n        return new Reduce(fn, accumulator);\n    }\n}\n\n\n/**\nPromiseStream(promise)\n**/\n\nclass PromiseStream extends Stream {\n    constructor(promise) {\n        super();\n        this.promise = promise;\n    }\n\n    start() {\n        this.promise\n        .then((value) => push(this, value))\n        .finally(() => this.stop());\n        return this;\n    }\n}\n\n\n/*\nValue(value)\nA Value stream represents a persistent value. Streams piped from a value stream\nare given its current value. A Value stream may be pushed to before it is piped.\n*/\n\nclass Value extends Stream {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n\n    start() {\n        if (this.value !== undefined) {\n            push(this, this.value);\n            // If stream was stopped as a result of a push, don't continue pushing\n            if (this.status === 'done') return this;\n        }\n\n        // Start streams that are piped to this buffer stream\n        return super.start();\n    }\n\n    push(value) {\n        this.value = value;\n        return push(this, value);\n    }\n}\n\n\n/*\nBufferStream(values)\nA BufferStream may be pushed to before it is piped, as it starts life with an\narray buffer of values.\n*/\n\nclass BufferStream extends Stream {\n    constructor(values) {\n        super();\n        this.values = values || [];\n    }\n\n    start() {\n        const values = this.values;\n        if (!values) return super.start();\n\n        // Loop over values\n        let n = -1;\n        while(n++ < values.length) {\n            // Push values to stream\n            push(this, values[n]);\n            // If stream was stopped as a result of a push, don't continue pushing\n            if (this.status === 'done') return this;\n        }\n\n        // Throw away values buffer\n        this.values = undefined;\n\n        // Start streams that are piped to this buffer stream\n        return super.start();\n    }\n\n    push(value) {\n        this.value = value;\n        return this.values ?\n            this.values.push(this.value) :\n            push(this, this.value) ;\n    }\n}\n\n\n/* Filter() */\n\nclass Filter extends Stream {\n    constructor(fn) {\n        super();\n        this.fn = fn;\n    }\n\n    push(value) {\n        const fn = this.fn;\n        return fn(value) && push(this, value);\n    }\n}\n\n\n/* FlatMap() */\n\nclass FlatMap extends Stream {\n    constructor(fn) {\n        super();\n        this.fn = fn;\n    }\n\n    push(value) {\n        const fn     = this.fn;\n        const values = fn(value);\n\n        if (values === undefined) { return; }\n\n        // Flatten array or array-like\n        if (isIterable(values)) {\n            for (const value of values) {\n                push(this, value);\n            }\n        }\n        // Flatten stream\n        else if (values.pipe) {\n            console.warn('FlatMapping pipeables is dodgy. Map to arrays for the moment please.');\n            // Todo: support flattening of streams. This method is crude -\n            // it does not preserve order, for one thing. Should streams be\n            // made iterable? CAN streams be made iterable? They'd have to\n            // be async...\n            this.done(values.each((value) => push(this, value)));\n            // This causes problems if you try\n            // stream.scan(...).flatMap(...)\n            //values.pipe(this[0]);\n        }\n        // Flatten promise\n        else if (values.then) {\n            values.then((value) => push(this, value));\n        }\n    }\n}\n\n\n/* Map() */\n\nclass Map extends Stream {\n    constructor(fn) {\n        super();\n        this.fn = fn;\n    }\n\n    push(value) {\n        const fn     = this.fn;\n        const result = fn(value);\n        // Reject undefined\n        return result !== undefined && push(this, result);\n    }\n}\n\n\n/*\nMerge()\n*/\n\nclass Merge extends Stream {\n    constructor(inputs) {\n        super();\n        this.inputs = inputs;\n    }\n\n    push(value) {\n        return push(this, value);\n    }\n\n    pipe(output) {\n        let n = -1, input;\n        while (input = this.inputs[++n]) Stream.from(input).pipe(this);\n        return Stream.prototype.pipe.call(this, output)\n    }\n}\n\n\n/* Scan() */\n\nclass Scan extends Stream {\n    constructor(fn, accumulator) {\n        super();\n        this.fn    = fn;\n        this.value = accumulator;\n    }\n\n    push(value) {\n        const fn = this.fn;\n        this.value = fn(this.value, value);\n        push(this, this.value);\n    }\n}\n\n\n/* Slice() */\n\nclass Slice extends Stream {\n    constructor(n, m = Infinity) {\n        if (window.DEBUG && (typeof n !== 'number' || n < 0)) {\n            throw new Error('Stream: .slice() requires a positive integer (' + n + ')');\n        }\n\n        if (window.DEBUG && (typeof m !== 'number' || m < 1)) {\n            throw new Error('Stream: .slice() requires a non-zero positive integer (n, ' + n + ')');\n        }\n\n        super();\n        this.index = -n;\n        this.indexEnd = m - n;\n    }\n\n    push(value) {\n        if (++this.index > 0) push(this, value);\n        if (this.index === this.indexEnd) this.stop();\n    }\n}\n\n\n/* Split(input, fn) */\n\nclass Split extends Stream {\n    constructor(fn) {\n        super();\n        this.chunk = [];\n\n        if (typeof fn === 'number') this.n = fn;\n        else this.fn = fn;\n    }\n\n    fn() {\n        return this.chunk.length === this.n;\n    }\n\n    push(value) {\n        const chunk = this.chunk;\n\n        if (this.fn(value)) {\n            // Emit complete chunk and create a new chunk\n            push(this, chunk);\n            this.chunk = [];\n        }\n        else {\n            // Push to existing chunk\n            chunk.push(value);\n        }\n    }\n}\n", "\n/**\nevents(type, element)\nevents(type, element, initial)\n\nReturns a mappable stream of events heard on `element`.\n\n```js\nevents('click', element)\n.map((e) => e.target.id)\n```\n\nThe first parameter may alternatively be an options object, in which case it\nmust have a `.type` property.\n\n```js\nevents({ type: 'click' }, element)\n.map((e) => e.target.id)\n```\n\nThe object may contain a number of other properties that select the events\nreceived. It supports the standard addEventListener options, for passive and\ncapture phase event binding.\n\n```js\nevents({ type: 'scroll', passive: true, capture true }, window)\n.map((e) => window.scrollTop)\n```\n\nAnd a `.select` property, a CSS selector, that filters events to those with\ntargets that match or have a `closest()` ancestor that matches the selector.\n\n```js\nevents({ type: 'click', select: '[name=\"button\"]' }, element)\n.map((e) => e.target.id)\n```\n\nHowever, if you need to delegate events it is recommended to use the\n`delegate()` function, which has the added benefit of direct access to the\ndelegated target.\n\n```js\nevents('click', element)\n.each(delegate({\n    '[name=\"button\"]': (target, e) => console.log(target.id),\n    '[name=\"remove\"]': (target, e) => document.getElementById(target.value).remove(),\n    ...\n}))\n```\n\nStopping an event stream removes its event listeners.\n\n```js\nevents('click', element).stop()\n```\n\nPass in an `initial` object to have the event stream start synchronously\nwith the initial object when consumed.\n\n```js\nevents(type, element, initial)\n```\n**/\n\nimport cache  from 'fn/cache.js';\nimport Stream from 'fn/stream/stream.js';\n\nconst assign  = Object.assign;\nconst rspaces = /\\s+/;\nconst types   = {\n    fullscreenchange: cache(() => (\n        'fullscreenElement' in document ? 'fullscreenchange' :\n        'webkitFullscreenElement' in document ? 'webkitfullscreenchange' :\n        'mozFullScreenElement' in document ? 'mozfullscreenchange' :\n        'msFullscreenElement' in document ? 'MSFullscreenChange' :\n        'fullscreenchange'\n    ))\n};\n\n\n// DOM click events may be simulated on inputs when their labels are\n// clicked. The tell-tale is they have the same timeStamp. Track click\n// timeStamps.\nvar clickTimeStamp = 0;\n\nwindow.addEventListener('click', (e) => clickTimeStamp = e.timeStamp);\n\nfunction listen(listener, type) {\n    listener.node.addEventListener(types[type] ? types[type]() : type, listener, listener.options);\n    return listener;\n}\n\nfunction unlisten(listener, type) {\n    listener.node.removeEventListener(types[type] ? types[type]() : type, listener);\n    return listener;\n}\n\nclass Events extends Stream {\n    constructor(type, options, node, initialEvent) {\n        super();\n\n        // Potential hard-to-find error here if type has repeats, ie 'click click'.\n        // Lets assume nobody is dumb enough to do this, I dont want to have to\n        // check for that every time.\n        this.types        = type.split(rspaces);\n        this.options      = options;\n        this.node         = node;\n        this.select       = options && options.select;\n        this.modifiers    = options && options.modifiers;\n        this.initialEvent = initialEvent;\n    }\n\n    handleEvent(e) {\n        // Ignore clicks with the same timeStamp as previous clicks –\n        // they are likely simulated by the browser, eg. clicks on labels\n        // cause simulated clicks to be emitted from inputs\n        if (e.type === 'click' && e.timeStamp <= clickTimeStamp) return;\n\n        // Inspect modifier keys\n        if (this.modifiers) {\n            const modifiers = typeof this.modifiers === 'string' ?\n                this.modifiers.split(/\\s+/) :\n                this.modifiers ;\n\n            let n = modifiers.length;\n            while (n--) if (!e[modifiers[n] + 'Key']) return;\n        }\n\n        // If there is a selector and the target doesn't match, shoofty\n        // outta here\n        if (this.select) {\n            const selectedTarget = e.target.closest(this.select);\n            if (!selectedTarget) return;\n            e.selectedTarget = selectedTarget;\n        }\n\n        Stream.push(this, e);\n    }\n\n    start() {\n        this.types.reduce(listen, this);\n\n        if (this.initialEvent) {\n            this.handleEvent(this.initialEvent);\n            delete this.initialEvent;\n        };\n\n        return this;\n    }\n\n    stop() {\n        this.types.reduce(unlisten, this);\n        return super.stop();\n    }\n}\n\nexport default function events(type, node, initialEvent) {\n    let options;\n    if (typeof type === 'object') {\n        options = type;\n        type    = options.type;\n    }\n\n    return new Events(type, options, node, initialEvent);\n}\n", "/**\ncacheByKey(fn)\nReturns a function that caches the output values of `fn(input)` against input\nvalues, which are registered as keys in an object, such that for each input\nkey `fn` is only ever called once.\n*/\n\nlet warned;\n\nexport default function cacheByKey(fn) {\n    var map = {};\n\n    return function cache(input) {\n        /*if (window.DEBUG && !warned && input === undefined) {\n            warned = true;\n            console.warn('cacheByKey() called with undefined. Not illegal, but potentially bad.');\n        }\n\n        if (window.DEBUG && typeof input !== 'string' && typeof input !== 'number') {\n            console.warn('cacheByKey() called with non-primitive input, coerced to string \"' + input + '\"');\n        }*/\n\n        if (window.DEBUG && arguments.length > 1) {\n            console.warn('cacheByKey() called with ' + arguments.length + ' arguments. Accepts exactly 1.');\n        }\n\n        return input in map ?\n            map[input] :\n            map[input] = fn(input) ;\n    };\n}\n", "/**\nchoose(map)\nReturns a function that takes its first argument as a key and uses it\nto select a function in `map` which is invoked with the remaining arguments.\n\nWhere `map` has a function `default`, that function is run when a key\nis not found, otherwise unfound keys will error.\n\n```\nvar fn = choose({\n    'fish':  function fn1(a, b) {...},\n    'chips': function fn2(a, b) {...}\n});\n\nfn('fish',  a, b);      // Calls fn1(a, b)\nfn('chips', a, b);      // Calls fn2(a, b)\nfn('mayonnaise', a, b); // Error\n```\n\nIt's worth pointing out that the `this` context is also applied to `fn1` and\n`fn2`, making `choose(map)` suitable for creating object methods.\n*/\n\nexport default function choose(map) {\n    return function choose(key, ...params) {\n        var fn = map[key] || map.default;\n        return fn && fn.apply(this, params) ;\n    };\n}\n", "\nvar mimetypes = {\n    xml:  'application/xml',\n    html: 'text/html',\n    svg:  'image/svg+xml'\n};\n\nexport default function parse(type, string) {\n    if (!string) { return; }\n\n    // Accept 'svg' or 'SVG' or 'image/svg+xml'\n    var mimetype = mimetypes[type.toLowerCase()] || type;\n    var xml;\n\n    // Cludged from jQuery source...\n    try {\n        xml = (new window.DOMParser()).parseFromString(string, mimetype);\n    }\n    catch (e) {\n        return;\n    }\n\n    if (!xml || xml.getElementsByTagName(\"parsererror\").length) {\n        throw new Error(\"Invalid \" + type.toUpperCase() + \": \" + string);\n    }\n\n    return xml;\n}\n\n/**\nparseHTML(string)\nReturns an HTML document parsed from `string`, or undefined.\n*/\n\nexport function parseHTML(string) {\n    return parse('html', string);\n}\n\n/**\nparseSVG(string)\nReturns an SVG document parsed from `string`, or undefined.\n*/\n\nexport function parseSVG(string) {\n    return parse('svg', string);\n}\n\n/**\nparseXML(string)\nReturns an XML document parsed from `string`, or undefined.\n*/\n\nexport function parseXML(string) {\n    return parse('xml', string);\n}\n", "import choose  from 'fn/choose.js';\nimport id      from 'fn/id.js';\n\nimport create  from './create.js';\nimport { parseHTML, parseSVG } from './parse.js';\n\nconst assign = Object.assign;\n\n/*\nconfig\n\n```{\n    headers:    fn(data),    // Must return an object with properties to add to the header\n    body:       fn(data),    // Must return an object to send as data\n    onresponse: function(response)\n}```\n*/\n\nexport const config = {\n    // Takes data, returns headers\n    headers: function(data) { return {}; },\n\n    // Takes data (can be FormData object or plain object), returns data\n    body: id,\n\n    // Takes response, returns response\n    /*onresponse: function(response) {\n        // If redirected, navigate the browser away from here. Can get\n        // annoying when receiving 404s, maybe not a good default...\n        if (response.redirected) {\n            window.location = response.url;\n            return;\n        }\n\n        return response;\n    }*/\n};\n\nconst createHeaders = choose({\n    'application/x-www-form-urlencoded': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": 'application/x-www-form-urlencoded',\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    },\n\n    'application/json': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": \"application/json; charset=utf-8\",\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    },\n\n    'multipart/form-data': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": 'multipart/form-data',\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    },\n\n    'audio/wav': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": 'audio/wav',\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    },\n\n    'image/png': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": 'image/png',\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    },\n\n    'image/jpg': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": 'image/jpg',\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    },\n\n    'image/jpeg': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": 'image/jpeg',\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    },\n\n    'default': function(headers) {\n        return assign(headers, {\n            \"Content-Type\": 'application/x-www-form-urlencoded',\n            \"X-Requested-With\": \"XMLHttpRequest\"\n        });\n    }\n});\n\nconst createBody = choose({\n    'application/json': function(data) {\n        return data instanceof FormData ?\n            formDataToJSON(data) :\n            JSON.stringify(data);\n    },\n\n    'application/x-www-form-urlencoded': function(data) {\n        return data instanceof FormData ?\n            formDataToQuery(data) :\n            dataToQuery(data) ;\n    },\n\n    'multipart/form-data': function(data) {\n        return data instanceof FormData ?\n            data :\n            dataToFormData(data) ;\n    },\n\n    default: id\n});\n\nfunction formDataToJSON(formData) {\n    return JSON.stringify(\n        // formData.entries() is an iterator, not an array\n        Array\n        .from(formData.entries())\n        .reduce(function(output, entry) {\n            output[entry[0]] = entry[1];\n            return output;\n        }, {})\n    );\n}\n\nfunction formDataToQuery(data) {\n    return new URLSearchParams(data).toString();\n}\n\nfunction dataToQuery(data) {\n    return Object.keys(data).reduce((params, key) => {\n        params.append(key, data[key]);\n        return params;\n    }, new URLSearchParams());\n}\n\nfunction dataToFormData(data) {\n    throw new Error('TODO: dataToFormData(data)');\n}\n\nfunction urlFromData(url, data) {\n    // Form data\n    return data instanceof FormData ?\n        url + '?' + formDataToQuery(data) :\n        url + '?' + dataToQuery(data) ;\n}\n\nexport function createOptions(method, data, head, controller) {\n    const contentType =\n        typeof head === 'string' ? head :\n        head && head['Content-Type'] ||\n        'application/json' ;\n\n    const headers = createHeaders(contentType, assign(\n        config.headers && data ? config.headers(data) : {},\n        typeof head === 'string' ? {} : head\n    ));\n\n    const options = {\n        method:  method,\n        mode: \"cors\",\n        headers: headers,\n        credentials: 'same-origin',\n        signal: controller && controller.signal\n    };\n\n    if (method !== 'GET') {\n        options.body = createBody(contentType, config.body ? config.body(data) : data);\n    }\n\n    return options;\n}\n\nfunction respondBlob(response) {\n    return response.blob();\n}\n\nfunction respondJSON(response) {\n    return response.json().catch((e) => {\n        throw new Error('Cannot parse JSON ' + response.url + '. ' + e.message + '');\n    });\n}\n\nfunction respondForm(response) {\n    return response.formData();\n}\n\nfunction respondText(response) {\n    return response.text();\n}\n\nfunction respondDOM(response) {\n    return response.text().then((text) => (\n        // Is it a document?\n        /^\\s*<!DOCTYPE html>/.test(text) ?\n            parseHTML(text) :\n            create('fragment', text)\n    ));\n}\n\nfunction respondSVG(response) {\n    return response.text().then((text) => (\n        // Is it a document?\n        /^\\s*<\\?xml/.test(text) ?\n            parseSVG(text) :\n            // TODO: untested, don't know if this works on partial SVG\n            // fragments, I think probably not, I think we need to maybe\n            // make a <defs> instead. You have been warned.\n            (console.warn('Untested SVG fragment parsing in request.js!'),\n            create('fragment', text))\n    ));\n}\n\nconst responders = {\n    'text/plain':                        respondText,\n    'text/html':                         respondDOM,\n    'image/svg+xml':                     respondSVG,\n    'application/json':                  respondJSON,\n    'multipart/form-data':               respondForm,\n    'application/x-www-form-urlencoded': respondForm,\n    'audio':                             respondBlob,\n    'audio/wav':                         respondBlob,\n    'audio/m4a':                         respondBlob,\n    'application/zip':                   respondBlob\n};\n\nfunction respond(response) {\n    if (config.onresponse) {\n        response = config.onresponse(response);\n    }\n\n    if (!response.ok) {\n        throw new Error(response.statusText + '');\n    }\n\n    // Get mimetype from Content-Type, remembering to hoik off any\n    // parameters first\n    const contentType = response.headers.get('Content-Type');\n\n    if(!contentType) { return; }\n    const mimetype = contentType.replace(/\\;.*$/, '');\n\n    if (window.DEBUG && !responders[mimetype]) {\n        console.warn('request() has no built-in response parser for mimetype \"' + mimetype + '\"');\n    }\n\n    return responders[mimetype](response);\n}\n\n\n/**\nrequest(method, url, data, mimetype | headers)\n\nUses `fetch()` to send a request to `url`. Where `type` is `\"GET\"`, `data` is\nserialised and appended to the URL, otherwise it is sent as a request body.\nThe 4th parameter may be a content type string or a headers object (in which\ncase it must have a `'Content-Type'` property).\n**/\n\nexport default function request(method = 'GET', url, data = {}, contenttype = 'application/json') {\n    method = method.toUpperCase();\n\n    // If this is a GET and there is data, append data to the URL query string\n    if (method === 'GET' && data) {\n        url = urlFromData(url, data);\n    }\n\n    // param[4] is an optional abort controller\n    const options = createOptions(method, data, contenttype, arguments[4]);\n\n    return fetch(url, options).then(respond);\n}\n\n/**\nrequestGet(url)\nA shortcut for `request('get', url, null, 'application/json')`\n**/\n\nexport function requestGet(url) {\n    return request('GET', url);\n}\n\n/**\nrequestPatch(url, data)\nA shortcut for `request('patch', url, data, 'application/json')`\n**/\n\nexport function requestPatch(url, data) {\n    return request('PATCH', url, data, 'application/json');\n}\n\n/**\nrequestPost(url, data)\nA shortcut for `request('post', url, data, 'application/json')`\n**/\n\nexport function requestPost(url, data) {\n    return request('POST', url, data, 'application/json');\n}\n\n/**\nrequestDelete(url, data)\nA shortcut for `request('delete', url, data, 'application/json')`\n**/\n\nexport function requestDelete(url, data) {\n    return request('DELETE', url, data, 'application/json');\n}\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n\twindow.dom ? (window.dom.request = request) : (window.dom = { request });\n}\n", "const lengths = {\n    /* Length of data following 'type' */\n    chord: 3, /* chord duration, not used, chords can be either 2 or 3 long */\n    note:  3, /* pitch gain duration */\n    key:   1, /* A-G */\n    meter: 2, /* duration division */\n    rate:  1, /* rate */\n    lyric: 2, /* string, duration */\n};\n\nconst rnote = /^[ABCDEFG][b♭#♯]{0,1}-?\\d$/;\nconst rroot = /^[ABCDEFG][b♭#♯]{0,1}/;\n\n\nexport default function parseSequenceText(source) {\n    const data   = source.trim().split(/\\s+/);\n    const events = [];\n\n    let n = -1;\n    while (data[++n] !== undefined) {\n        let time  = Number(data[n]);\n        let type  = data[++n];\n\n        // Automatically detect type. If type has been omitted, it will match\n        // a value for note pitch or chord. Set type, rewind n.\n        if (rnote.test(type)) {\n            type = 'note';\n            --n;\n        }\n        else if (rroot.test(type)) {\n            type = 'chord';\n            --n;\n        }\n\n        let event = [time, type];\n        let m = lengths[type];\n        if (m === undefined) {\n            throw new TypeError('Unrecognised type \"' + type + '\" in sequence data');\n        }\n\n        if (type === 'chord') {\n            // Detect and parse chord root/extension written as one\n            // parameter \"C7\" or as two \"C\", \"7\"\n            let root      = rroot.exec(data[++n])[0];\n            let extension = data[n].slice(root.length) || data[++n];\n            let duration  = Number(data[++n]);\n            event.push(root, extension, duration);\n        }\n        else {\n            // Push values into event, converting to number where possible\n            while (m--) {\n                let value = Number(data[++n]);\n                event.push(Number.isNaN(value) ? data[n] : value);\n            }\n        }\n\n        events.push(event);\n    }\n\n    return events;\n}\n", "//import parseABC          from './parse/parse-abc.js';\nimport parseSequenceText from './parse/parse-sequence-text.js';\n\n\n/* Parse data\n  (TODO: Yeah, API requests need tidied up) */\n\nfunction fromGist(gist) {\n    // Get first file\n    const file = gist.files[Object.keys(gist.files)[0]];\n    return parseSource(file.type, file.content);\n}\n\nfunction fromTheSession(object) {\n    // Get first file\n    const song = object.settings.find(matches({ id: 13324 })) || object.settings[0];\n    return parseSource('abc', song.abc);\n}\n\nexport default function parseSource(type, source) {\n    // source is an object\n    if (typeof source === 'object') {\n        // source is json from api.github.com/gists/\n        return source.files ? fromGist(source) :\n        // source is from thesession.org\n        source.settings ? fromTheSession() :\n        // source is an events array\n        Array.isArray(source) ? { id: 0, events: source } :\n        // source is a sequence object\n        source ;\n    }\n    // Data is ABC\n/*\n    else if (type === 'abc' || type === 'text/x-abc') {\n        // Strip space following line breaks\n        const music = parseABC(source.replace(/\\n\\s+/g, '\\n'));\n        return music.sequences[0];\n    }\n*/\n    // Data is step sequence text\n    else if (type === 'sequence' || type === 'text/plain') {\n        return { events: parseSequenceText(source) };\n    }\n    // Data is JSON\n    else {\n        const events = JSON.parse(source);\n        return Array.isArray(events) ?\n            { id: 0, events } :\n            events ;\n    }\n}\n", "\nimport cache          from 'fn/cache-by-key.js';\nimport overload       from 'fn/overload.js';\nimport { requestGet } from 'dom/request.js';\nimport parse          from './parse.js';\n\nconst requestData = cache(requestGet);\nconst rpath       = /^\\.*\\/|^https?:\\/\\//;\n\n/**\nrequestData(type, url)\n**/\n\nexport default overload((type, value) => typeof value, {\n    string: function(type, url) {\n        if (window.DEBUG && !rpath.test(url)) {\n            throw new TypeError('URL not supported \"' + url + '\"');\n        }\n\n        return requestData(url)\n        .then((source) => parse(type, source))\n        .catch((error) => console.error(error));\n    },\n\n    default: function(name, internals, type, value) {\n        internals[name] = value;\n    }\n});\n", "\nconst rtimesig = /^(\\d+)\\/(\\d+)$/;\n\nexport function timesigToMeter(string) {\n    const groups = rtimesig.exec(string);\n    const num = parseInt(groups[1], 10);\n    const div = 4 / parseInt(groups[2], 10);\n    // Returns an object that can be assigned to a meter event\n    return { 1: 'meter', 2: num * div, 3: div };\n}\n\nexport function meterToTimesig(meter) {\n    const dur = meter[2];\n    const div = meter[3];\n    const num = dur / div;\n    const den = 4 / div;\n    return num + '/' + den;\n}\n", "\nimport Signal                    from 'fn/signal.js';\nimport create                    from 'dom/create.js';\nimport element, { getInternals } from 'dom/element.js';\nimport events                    from 'dom/events.js';\nimport { toRootName, toRootNumber } from 'midi/note.js';\n\nimport requestData       from '../modules/request-data.js';\nimport parseSource       from '../modules/parse.js';\nimport { timesigToMeter, meterToTimesig } from '../modules/timesig.js';\nimport Stave             from '../modules/stave.js';\nimport { renderBeam }    from '../modules/beam.js';\nimport render            from '../modules/render.js';\nimport config            from '../modules/config.js';\n\nconst assign = Object.assign;\nconst define = Object.defineProperties;\n\n/* ScribeMusic.stylesheet */\nconst shadowCSSUrl = new URL('shadow.css', import.meta.url);\nconst stylesheet = Signal.of();\nconst stylefns   = [];\n//stylesheet.each((url) => stylefns.forEach((fn) => fn(url)));\n\n/* Element resizing */\nconst resizes = new ResizeObserver((entries) => {\n    for (const entry of entries) {\n        // Render beams\n        getInternals(entry.target)\n        .shadowRoot\n        .querySelectorAll('.beam')\n        .forEach(renderBeam);\n    }\n});\n\n\n/* Register <scribe-music> */\n\nexport default define(element('scribe-music', {\n    shadow: `<link rel=\"stylesheet\" href=\"${ shadowCSSUrl }\" />`,\n\n    construct: function(shadow, internals) {\n        // Listen to updates to ScribeMusic.stylesheet and update the link\n        const stylelink = shadow.querySelector('link');\n        stylefns.push((url) => stylelink.href = url);\n        if (stylesheet.value) stylelink.href = stylesheet.value;\n\n        // Set up listeners for attribute/property changes\n        internals.data      = Signal.of();\n        internals.clef      = Signal.of('treble');\n        internals.key       = Signal.of('C');\n        internals.meter     = Signal.of([-4, \"meter\", 4, 1]);\n        internals.transpose = Signal.of(0);\n        internals.swingAsStraight8ths  = Signal.of(false);\n        internals.swingAsStraight16ths = Signal.of(false);\n        internals.debug     = Signal.of(false);\n\n        /* Safari has some rounding errors to overcome... */\n        internals.isSafari = navigator.userAgent.includes('AppleWebKit/')\n            && !navigator.userAgent.includes('Chrome/')\n            && !navigator.userAgent.includes('Edge/')\n            && !navigator.userAgent.includes('Gecko/');\n    },\n\n    connect: function(shadow, internals) {\n        // If Safari\n        if (internals.isSafari) {\n            this.classList.add('safari');\n        }\n\n        // Update beams on load and resize\n        resizes.observe(this, { box: 'content-box' });\n\n        // If there is no src use text content as data\n        if (!this.src) {\n            const source = this.textContent.trim();\n            internals.data.value = parseSource(this.type, source);\n        }\n\n        // Listens to changes\n        return Signal.frame(() => {\n            const elements = internals.data.value && render(\n                // Events from data\n                internals.data.value,\n                // Clef is a string\n                internals.clef.value,\n                // Key name\n                internals.key.value,\n                // Create an initial [0, \"meter\", ...] event\n                internals.meter.value,\n                // Transpose is a number\n                internals.transpose.value,\n                // Override settings from attributes\n                assign({}, config, {\n                    swingAsStraight8ths:  internals.swingAsStraight8ths.value,\n                    swingAsStraight16ths: internals.swingAsStraight16ths.value\n                })\n            );\n\n            // Clear the shadow DOM of bars and put new elements in it\n            shadow.querySelectorAll('.bar').forEach((element) => element.remove());\n            shadow.append.apply(shadow, elements);\n\n            // Render beams\n            shadow.querySelectorAll('.beam').forEach(renderBeam);\n\n            // DEBUG\n\n            // Does bar contain symbols that add up to longer than bar?\n            if (internals.debug.value) {\n                shadow.querySelectorAll('.bar').forEach((bar) => {\n                    const duration = parseFloat(bar.dataset.duration);\n                    let total = 0;\n                    let b, d;\n\n                    if (bar.querySelector('.BARREPEAT')) {\n                        return;\n                    }\n\n                    bar.querySelectorAll('.rest[data-duration], .note[data-duration]').forEach((element) => {\n                        // Ignore notes that are at same beat as previous notes\n                        if (b !== parseFloat(element.dataset.beat)) {\n                            b = parseFloat(element.dataset.beat);\n                            d = parseFloat(element.dataset.duration);\n                            total += d;\n                        }\n                    });\n                    if (Math.round(total / 0.0625) !== Math.round(duration / 0.0625)) {\n                        bar.classList.add('error');\n                    }\n                });\n            }\n        });\n    },\n\n    disconnect: function() {\n        resizes.unobserve(this);\n    }\n}, {\n    clef: {\n        /**\n        clef=\"treble\"\n        Choose the default clef to render. Not that if the rendered sequence\n        contains clef events, they override this choice. Possible clefs are\n        `\"treble\"`, `\"bass\"`, `\"piano\"`, `\"drum\"`, `\"percussion\"`, `\"chord\"`.\n        **/\n        attribute: function(value) { this.clef = value; },\n\n        /**\n        .clef = \"treble\"\n        Choose the default clef to render. Not that if the rendered sequence\n        contains clef events, they override this choice. Possible clefs are\n        `\"treble\"`, `\"bass\"`, `\"piano\"`, `\"drum\"`, `\"percussion\"`, `\"chord\"`.\n        **/\n        get: function() {  return getInternals(this).clef.value; },\n        set: function(value) {\n            if (!Stave[value]) {\n                console.warn('<scribe-music> Attempt to set invalid clef=\"' + value + '\" ignored');\n                return;\n            }\n\n            getInternals(this).clef.value = value;\n        }\n    },\n\n    key: {\n        /**\n        key=\"C\"\n        Choose the key signature. Defaults to \"C\".\n        **/\n        attribute: function(value) {\n            this.key = value === '' ? 'C' : value;\n        },\n\n        /**\n        .key=\"C\"\n        Choose the key signature.\n        **/\n        get: function() { return getInternals(this).key.value; },\n        set: function(value) {\n            const internals = getInternals(this);\n\n            // Validate\n            if (typeof value !== 'string' || !/^[A-G][#b♯♭]?$/.test(value)) {\n                console.warn('<scribe-music> Attempt to set invalid key=\"' + value + '\" ignored');\n                return;\n            }\n\n            // Set\n            internals.key.value = value.replace(/[#b]$/, ($0) => $0 === '#' ? '♯' : '♭');\n        }\n    },\n\n    meter: {\n        /**\n        meter=\"4/4\"\n        Sets the meter. Note that this is overridden by any `\"meter\"` event\n        found at beat `0` in the data.\n        **/\n        attribute: function(value) {\n            // Default to 4/4 where meter attribute simply exists\n            this.meter = value === '' ? '4/4' : value;\n        },\n\n        /**\n        .meter = \"4/4\"\n        Sets the meter. Note that this is overridden by any `\"meter\"` event\n        found at beat `0` in the data.\n        **/\n        get: function() { return meterToTimesig(getInternals(this).meter.value); },\n        set: function(value) { getInternals(this).meter.value = assign([0], timesigToMeter(value)); }\n    },\n\n    transpose: {\n        /**\n        transpose=\"0\"\n        Sets transposition value for display of notation.\n        **/\n        attribute: function(value) { this.transpose = value; },\n\n        /**\n        .transpose = 0\n        Sets transposition value for display of notation.\n        **/\n        get: function() { return getInternals(this).transpose.value; },\n        set: function(value) {\n            // Set integer from value\n            getInternals(this).transpose.value = typeof value === 'number' ?\n                Math.round(value) :\n                parseInt(value, 10) ;\n        }\n    },\n\n    type: {\n        /**\n        type=\"application/json\"\n        Mimetype or type of data to fetch. Possible mimetypes:\n        - `\"text/x-abc\"`\n        - `\"text/plain\"`\n        - `\"application/json\"`\n        **/\n        attribute: function(value) { this.type = value; },\n\n        /**\n        .type = \"application/json\"\n        Mimetype or type of data to fetch. Possible mimetypes:\n        - `\"text/x-abc\"`\n        - `\"text/plain\"`\n        - `\"application/json\"`\n        **/\n        writable: true,\n        value: 'application/json'\n    },\n\n    /**\n    src=\"url\"\n    A path to an ABC, JSON or SEQUENCE file\n    **/\n    src: {\n        attribute: function(src) { this.src = src; },\n        get: function() { return getInternals(this).src; },\n        set: function(src) {\n            const internals = getInternals(this);\n            internals.src = src;\n            const url = new URL(src, window.location);\n\n            // src points to a hash in current document\n            if (window.location.origin === url.origin && window.location.pathname === url.pathname) {\n                const script = this.getRootNode().getElementById(url.hash.slice(1));\n                if (!script) throw new Error('<scribe-music> src script \"' + src + '\" not found in document');\n                this.data = JSON.parse(script.textContent);\n            }\n            else {\n                requestData(this.type, url.href)\n                .then((data) => this.data = data);\n            }\n        },\n        default:   null\n    },\n\n    /**\n    .data\n    **/\n    data: {\n        get: function() { return getInternals(this).data.value; },\n        set: function(data) { getInternals(this).data.value = data; },\n        default: null\n    },\n\n    swing: {\n        attribute: function(value) { getInternals(this).swingAsStraight8ths.value = value !== null; }\n    },\n\n    shuffle: {\n        attribute: function(value) { getInternals(this).swingAsStraight16ths.value = value !== null; }\n    },\n\n    debug: {\n        attribute: function(value) { this.debug = value !== null; },\n        get: function() { return getInternals(this).debug.value; },\n        set: function(value) { getInternals(this).debug.value = !!value; }\n    }\n}, null, 'github.com/stephband/scribe/'), {\n    // Define ScribeMusic.styleheet as the stylesheet signal\n    stylesheet: {\n        set: (url) => stylesheet.value = url,\n        get: ()    => stylesheet.value\n    }\n});\n"],
  "mappings": "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",
  "names": ["evaluatingSignal", "hasInvalidDependency", "removeOutput", "signal", "output", "o", "clearInputs", "n", "setDependency", "dependent", "invalidateDependents", "hasInput", "input", "Signal", "_Signal", "object", "value", "ValueSignal", "fn", "context", "PushSignal", "ComputeSignal", "name", "PropertySignal", "FrameSignal", "TickSignal", "TimedSignal", "previous", "evaluatingSignal", "hasInvalidDependency", "#value", "#valid", "#fn", "#context", "#validTime", "time", "isValid", "Observer", "m", "observers", "i", "rendering", "render", "promise", "tick", "frame", "exec", "regex", "fn", "string", "data", "tokens", "output", "exec_default", "curry_default", "error", "regex", "reducers", "string", "reduce", "acc", "tokens", "n", "capture", "output", "exec", "capture_default", "curry_default", "$internals", "createInternals", "Element", "element", "shadow", "getInternals", "define", "constructors", "formProperties", "name", "getInternals", "supportsCustomisedBuiltIn", "parseNameTag", "capture_default", "data", "captures", "onceEvent", "toLoadPromise", "element", "resolve", "reject", "stop", "object", "getElementConstructor", "tag", "constructor", "transferProperty", "key", "value", "createShadow", "elem", "options", "shadow", "link", "create_default", "fillShadowFromTemplate", "template", "isNotUpgraded", "upgraded", "findByIs", "root", "createDescriptor", "overload", "descriptor", "fn", "definition", "lifecycle", "properties", "log", "attributes", "descriptors", "propname", "Element", "internals", "createInternals", "define", "disabled", "old", "links", "style", "promise", "div", "noop", "upgrade", "store", "n", "attribute", "polyfillByRoot", "to_type_default", "object", "define", "call", "overload", "to_type_default", "fn", "object", "Stopable", "id", "#stopables", "stopables", "throwTypeError", "source", "push", "stream", "value", "stop", "Stopable", "o", "output", "removeInput", "input", "i", "removeOutput", "unpipe", "Consumer", "Each", "fn", "Reduce", "accumulator", "Stream", "inputloop", "values", "BufferStream", "Filter", "FlatMap", "Map", "initial", "Scan", "n", "m", "Slice", "Split", "setResolve", "res", "rej", "noop", "overload", "to_type_default", "object", "PromiseStream", "Value", "inputs", "Merge", "promise", "result", "chunk", "types", "cacheByObject", "clickTimeStamp", "cacheByKey", "fn", "map", "input", "choose", "map", "key", "params", "fn", "mimetypes", "parse", "type", "string", "mimetype", "xml", "parseHTML", "parseSVG", "assign", "config", "data", "id", "createHeaders", "choose", "headers", "createBody", "formDataToJSON", "formDataToQuery", "dataToQuery", "dataToFormData", "formData", "output", "entry", "params", "key", "urlFromData", "url", "createOptions", "method", "head", "controller", "contentType", "options", "respondBlob", "response", "respondJSON", "e", "respondForm", "respondText", "respondDOM", "text", "parseHTML", "create_default", "respondSVG", "parseSVG", "responders", "respond", "mimetype", "request", "contenttype", "requestGet", "lengths", "rnote", "rroot", "parseSequenceText", "source", "data", "events", "n", "time", "type", "event", "m", "root", "extension", "duration", "value", "fromGist", "gist", "file", "parseSource", "fromTheSession", "object", "song", "type", "source", "parseSequenceText", "events", "requestData", "cacheByKey", "requestGet", "request_data_default", "overload", "type", "value", "url", "requestData", "source", "parseSource", "error", "name", "internals", "rtimesig", "timesigToMeter", "string", "groups", "num", "div", "meterToTimesig", "meter", "dur", "den", "assign", "define", "shadowCSSUrl", "stylesheet", "Signal", "stylefns", "resizes", "entries", "entry", "getInternals", "renderBeam", "element_default", "element", "shadow", "internals", "stylelink", "url", "source", "parseSource", "elements", "render", "config_default", "bar", "duration", "total", "b", "d", "value", "stave_default", "$0", "meterToTimesig", "timesigToMeter", "src", "script", "request_data_default", "data"]
}
